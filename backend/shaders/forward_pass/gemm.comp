#version 460

#define TS 32u
#define WPT 8u
#define RTS (TS/WPT)

layout(push_constant) uniform pushBlock {
      int total;
      int batchsize;
      int M;
      int N;
      int K;
      int power_of_two;
} p;

layout (local_size_x = 16, local_size_y = 16, local_size_z = 1) in;

layout (binding = 0) readonly buffer ssbA {
  float A[];
};

layout (binding = 1) readonly buffer ssbB {
  float B[];
};

layout (binding = 2)  buffer ssbC {
  float C[];
};

void gemm_1(){
    int M = p.M;
    int N = p.N;
    int K = p.K;
    int b = p.batchsize;
    // Compute a single element (loop over K)
    for(uint globalDepth = gl_GlobalInvocationID.z; globalDepth < b; globalDepth += gl_NumWorkGroups.z * gl_WorkGroupSize.z){
        for (uint globalRow = gl_GlobalInvocationID.x; globalRow < M; globalRow += gl_NumWorkGroups.x * gl_WorkGroupSize.x){
            for (uint globalCol = gl_GlobalInvocationID.y; globalCol < N; globalCol += gl_NumWorkGroups.y * gl_WorkGroupSize.y){
                float acc = 0.0;
                for (uint k=0u; k < K; k++)
                    acc = fma(A[globalDepth*M*K + globalRow*K + k], B[k*N + globalCol], acc); 
                C[globalDepth*M*N + globalRow*N + globalCol] = acc;
            }
        }
    }
}



#define TSM 512u                     // The tile-size in dvolension M
#define TSN 512u                     // The tile-size in dvolension N
#define TSK 64u                      // The tile-size in dvolension K
#define WPTM 8u                      // The amount of work-per-thread in dvolension M
#define WPTN 8u                     // The amount of work-per-thread in dvolension N
#define RTSM (TSM/WPTM)    // The reduced tile-size in dvolension M (TSM/WPTM number of threads)
#define RTSN (TSN/WPTN)   // The reduced tile-size in dvolension N (TSN/WPTN number of threads)
#define LPTA uint(float(TSK*WPTM*WPTN)/float(TSN)) // Loads-per-thread for A
#define LPTB uint(float(TSK*WPTM*WPTN)/float(TSM)) // Loads-per-thread for B
#define MOD2(x,y) ((x) % (y))
#define DIV2(x,y) ((x) / (y))


shared float Asub[TSK][TSM];    // Local memory to fit a tile of A and B
shared float Bsub[TSN][TSK+2];

void gemm_2(){
    // https://cnugteren.github.io/tutorial/pages/page8.html
    uint M = p.M;
    uint N = p.N;
    uint K = p.K;
    uint b = p.batchsize;
    uint tidm = gl_LocalInvocationID.x;
    uint tidn = gl_LocalInvocationID.y;
    uint offsetM = TSM * gl_WorkGroupID.x;
    uint offsetN = TSN * gl_WorkGroupID.y;

    float Areg;
    float Breg[WPTN];
    float acc[WPTM][WPTN];
    
    for(uint globalDepth = gl_GlobalInvocationID.z; globalDepth < b; globalDepth += gl_NumWorkGroups.z * gl_WorkGroupSize.z) {
        for (uint wn=0; wn < WPTN; ++wn) {
            for (uint wm=0; wm < WPTM; ++wm) 
                acc[wm][wn] = 0.0;
        }

        uint tiles = uint(K/TSK);
        float tilesf = float(K)/float(TSK);
        if(tilesf - tiles > 0)
            tiles++;
        if(tiles == 0)
            tiles = 1;

        for(uint t=0; t < tiles; ++t) {
            for(uint la  = 0; la < LPTA; ++la) {
                uint tid = tidn*RTSM + tidm;
                uint id = la*RTSN*RTSM + tid;
                uint row = id%TSM;
                uint col = id/TSM;
                uint tileidx = TSK*t + col;
                Asub[col][row] = A[globalDepth*M*K + tileidx*M + offsetM + row];
                Bsub[row][col] = B[globalDepth*N*K + tileidx*N + offsetN + row];
            }

            barrier();

            for(uint k=0; k < TSK; ++k) {
                for (uint wn=0; wn < WPTN; ++wn) {
                    uint col = tidn + wn*RTSN;
                    Breg[wn] = Bsub[col][k];
                }

                for (uint wm=0; wm < WPTM; ++wm) {
                    uint row = tidm + wm*RTSM;
                    Areg = Asub[k][row];
                    for (uint wn=0; wn < WPTN; ++wn)
                        acc[wm][wn] =fma(Areg, Breg[wn], acc[wm][wn]);
                }
            }

            barrier();        

        }

        for (int wm=0; wm < WPTM; ++wm) {
            uint globalRow = offsetM + tidm + wm*RTSM;
            for (int wn=0; wn < WPTN; ++wn) {
                uint globalCol = offsetN + tidn + wn*RTSN;
                C[globalDepth*M*N + globalCol*M + globalRow] =  acc[wm][wn];
            }
        }
    }
}

/*
#define WIDTH 64u
#define UNROLL1 1u
#define UNROLL2 8u
#define A_at(i,j) A[j*offset_a + i]
#define B_at(i,j) B[j*offset_b + i]
#define C_at(i,j) C[j*offset_c + i]

shared float cc0[WIDTH];
shared float cc1[WIDTH];
shared float cc2[WIDTH];
shared float cc3[WIDTH];
shared float cc4[WIDTH];
shared float cc5[WIDTH];
shared float cc6[WIDTH];
shared float cc7[WIDTH];

void gemm_4() {
    uint M = p.M;
    uint N = p.N;
    uint K = p.K;
    uint offset_a = gl_WorkGroupID.x;
    uint offset_b = 1;
    uint offset_c = gl_WorkGroupID.y;
    uint i = gl_WorkGroupID.x * gl_WorkGroupSize.x * UNROLL1 + gl_LocalInvocationID.x;
    uint j = gl_WorkGroupID.y * UNROLL2;
    uint tx = gl_LocalInvocationID.x;

    float acc_0 = 0.;
    float acc_1 = 0.;
    float acc_2 = 0.;
    float acc_3 = 0.;
    float acc_4 = 0.;
    float acc_5 = 0.;
    float acc_6 = 0.;
    float acc_7 = 0.;
    if(i < M){
        if(j < N)
            acc_0 = C_at(i, j);
        if(j+1 < N)
            acc_1 = C_at(i, j+1);
        if(j+2 < N)
            acc_2 = C_at(i, j+2);
        if(j+3 < N)
            acc_3 = C_at(i, j+3);
        if(j+4 < N)
            acc_4 = C_at(i, j+4);
        if(j+5 < N)
            acc_5 = C_at(i, j+5);
        if(j+6 < N)
            acc_6 = C_at(i, j+6);
        if(j+7 < N)
            acc_7 = C_at(i, j+7);
    }

    for(uint ks = 0; ks <= (K-1); ks += WIDTH){
        barrier();
        if((ks+tx) < K){
            if(j<N)
                cc0[tx] = A_at(ks+tx, j);
            if(j+1 < N)
                cc1[tx] = A_at(ks+tx, j+1);
            if(j+2 < N)
                cc2[tx] = A_at(ks+tx, j+2);
            if(j+3 < N)
                cc3[tx] = A_at(ks+tx, j+3);
            if(j+4 < N)
                cc4[tx] = A_at(ks+tx, j+4);
            if(j+5 < N)
                cc5[tx] = A_at(ks+tx, j+5);
            if(j+6 < N)
                cc6[tx] = A_at(ks+tx, j+6);
            if(j+7 < N)
                cc7[tx] = A_at(ks+tx, j+7);

        }
        barrier();

        for(uint k = ks; k <= ((ks+WIDTH)-1); k++){
            if(i < M){
                if(k < K){
                    acc_0 += B_at(i, k) * cc0[k-ks];
                    acc_1 += B_at(i, k) * cc1[k-ks];
                    acc_2 += B_at(i, k) * cc2[k-ks];
                    acc_3 += B_at(i, k) * cc3[k-ks];
                    acc_4 += B_at(i, k) * cc4[k-ks];
                    acc_5 += B_at(i, k) * cc5[k-ks];
                    acc_6 += B_at(i, k) * cc6[k-ks];
                    acc_7 += B_at(i, k) * cc7[k-ks];
                }
            }
        }
    }

    if(i < M){
        if(j < N)
            C_at(i, j) = acc_0;
        if(j+1 < N)
            C_at(i, j+1) = acc_1;
        if(j+2 < N)
            C_at(i, j+2) = acc_2;
        if(j+3 < N)
            C_at(i, j+3) = acc_3;
        if(j+4 < N)
            C_at(i, j+4) = acc_4;
        if(j+5 < N)
            C_at(i, j+5) = acc_5;
        if(j+6 < N)
            C_at(i, j+6) = acc_6;
        if(j+7 < N)
            C_at(i, j+7) = acc_7;
                
    }

}
*/

void main() {
    if((p.M < 512 && p.N < 512) || p.power_of_two == 1)
        gemm_2();    
    else 
        gemm_1();
}