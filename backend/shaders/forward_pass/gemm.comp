#version 460
#define TSM 128u                     // The tile-size in dvolension M
#define TSN 128u                     // The tile-size in dvolension N
#define TSK 16u                      // The tile-size in dvolension K
#define WPTM 8u                      // The amount of work-per-thread in dvolension M
#define WPTN 8u                     // The amount of work-per-thread in dvolension N
#define RTSM (TSM/WPTM)    // The reduced tile-size in dvolension M (TSM/WPTM number of threads)
#define RTSN (TSN/WPTN)   // The reduced tile-size in dvolension N (TSN/WPTN number of threads)
#define LPTA ((TSK*TSM)/(RTSM*RTSN)) // Loads-per-thread for A
#define LPTB ((TSK*TSN)/(RTSM*RTSN)) // Loads-per-thread for B
#define MOD2(x,y) ((x) % (y))
#define DIV2(x,y) ((x) / (y))

#define TS 32u
#define WPT 8u
#define RTS (TS/WPT)

layout(push_constant) uniform pushBlock {
      int total;
      int batchsize;
      int M;
      int N;
      int K;
} p;

layout (local_size_x = RTSM, local_size_y = RTSN, local_size_z = 1) in;

layout (binding = 0) readonly buffer ssbA {
  float A[];
};

layout (binding = 1) readonly buffer ssbB {
  float B[];
};

layout (binding = 2) writeonly buffer ssbC {
  float C[];
};



shared float Asub[TSK][TSM];    // Local memory to fit a tile of A and B
shared float Bsub[TSN][TSK+2];

void gemm_1(){
    int M = p.M;
    int N = p.N;
    int K = p.K;
    int b = p.batchsize;
    // Compute a single element (loop over K)
    for(uint globalDepth = gl_GlobalInvocationID.z; globalDepth < b; globalDepth += gl_NumWorkGroups.z * gl_WorkGroupSize.z){
        for (uint globalRow = gl_GlobalInvocationID.x; globalRow < M; globalRow += gl_NumWorkGroups.x * gl_WorkGroupSize.x){
            for (uint globalCol = gl_GlobalInvocationID.y; globalCol < N; globalCol += gl_NumWorkGroups.y * gl_WorkGroupSize.y){
                float acc = 0.0;
                for (uint k=0u; k < K; k++)
                    acc += A[globalDepth*M*K + globalRow*K + k] * B[k*N + globalCol]; // MxN = MxK KxN
                C[globalDepth*M*N + globalRow*N + globalCol] = acc;
            }
        }
    }
}

void gemm_2(){
    // https://cnugteren.github.io/tutorial/pages/page8.html
    uint M = p.M;
    uint N = p.N;
    uint K = p.K;

    uint tidm = gl_LocalInvocationID.x;
    uint tidn = gl_LocalInvocationID.y;
    uint offsetM = TSM * gl_WorkGroupID.x;
    uint offsetN = TSN * gl_WorkGroupID.y;

    float Areg;
    float Breg[WPTN];
    float acc[WPTM][WPTN];

    for (uint wn=0; wn < WPTN; wn++) {
        Breg[wn] = 0.0;
        for (uint wm=0; wm < WPTM; wm++) {
            acc[wm][wn] = 0.0;
        }
    }

    uint tiles = uint(K/TSK);
    if(tiles == 0)
        tiles = 1;

    for(uint t=0; t < tiles; ++t) {
        for(uint la  = 0; la < LPTA; la++){
            uint tid = tidn*RTSM + tidm;
            uint id = la*RTSN*RTSM + tid;
            uint row = MOD2(id,TSM);
            uint col = DIV2(id,TSM);
            uint tileidx = TSK*t + col;
            Asub[col][row] = A[tileidx*M + offsetM + row];
            Bsub[row][col] = B[tileidx*N + offsetN + row];
        }

        barrier();

        for(uint k=0; k < TSK; k++) {
            for (uint wn=0; wn < WPTN; wn++) {
                uint col = tidn + wn*RTSN;
                Breg[wn] = Bsub[col][k];
            }

            for (uint wm=0; wm < WPTM; wm++) {
                uint row = tidm + wm*RTSM;
                Areg = Asub[k][row];
                for (uint wn=0; wn < WPTN; wn++)
                    acc[wm][wn] += Areg * Breg[wn];
            }
        }

        barrier();        

    }

    for (int wm=0; wm < WPTM; wm++) {
        uint globalRow = offsetM + tidm + wm*RTSM;
        for (int wn=0; wn < WPTN; wn++) {
            uint globalCol = offsetN + tidn + wn*RTSN;
            C[globalCol*M + globalRow] =  acc[wm][wn];
        }
    }
}



void main() {
    if(p.batchsize == 1 && p.M > 1024 && p.N > 1024)
        gemm_2();
    else
        gemm_1();
}