#version 460
//https://becominghuman.ai/all-about-normalization-6ea79e70894b
//https://towardsdatascience.com/implementing-batch-normalization-in-python-a044b0369567

layout(push_constant) uniform pushBlock {
    int total;
    int batchsize;
    int C;
    float eps;
    float momentum;
    int upper_offset;
    int lower_offset;
} p;

layout (local_size_x = 1024, local_size_y = 1, local_size_z = 1) in;

layout (binding = 0) readonly buffer ssbA {
    float A[];
};

layout (binding = 1) readonly buffer ssbB {
    float gamma_beta[];
};

layout (binding = 2) buffer ssbD {
    float running_mean_var[];
};

layout (binding = 3) writeonly buffer ssbG {
    float B[];
};

layout (binding = 4) buffer ssbH {
    float centered_norm[];
};



shared float mean[1024];
shared float variation[1024];
shared float s_out[1024];

void _average(){
   
}


void b_norm(){
    float momentum = p.momentum;
    float eps = p.eps;
    int C = p.C;
    int u = p.upper_offset;
    int l = p.lower_offset;
    uint tid = gl_GlobalInvocationID.x;
    
    if(tid < C){
        running_mean_var[tid*2] = momentum * running_mean_var[tid*2] + (1 - momentum) * mean[tid];
        running_mean_var[tid*2 + 1] = momentum * running_mean_var[tid*2 + 1] + (1 - momentum) * variation[tid];        
    }

    for(uint i = 0; i < C; ++i){
        float std = sqrt(variation[i] + eps);
        for (uint x = gl_GlobalInvocationID.x; x < l; x += gl_NumWorkGroups.x * gl_WorkGroupSize.x){        
            for(uint n = 0; n < u; ++n){
                centered_norm[n*l*2 + x*2] = A[n*l*C + i*l + x] - mean[i];
                centered_norm[n*l*2 + x*2 + 1] = centered_norm[n*l*2 + x*2] / std;
                B[n*l*C + i*l + x] = gamma_beta[i*2] * centered_norm[n*l*2 + x*2 + 1] + gamma_beta[i*2+1];
                B[n*l*C + i*l + x] = centered_norm[n*l*2 + x*2 + 1]; //A[n*l*C + i*l + x];
            }
        }
    }
    /*      float std = sqrt(variation + eps);
            float x_centered = A[x*C+y] - mean;
            float x_norm = x_centered / std;
            B[x*C+y] = gamma[y] * x_norm + beta[y];
            centered[x*C + y] = x_centered;
            norm[x*C + y] = x_norm;
    */
}


void main(){
    //_average();
    //barrier();
    b_norm();
}