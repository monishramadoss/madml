#version 460

#define TSM 128u                     // The tile-size in dvolension M
#define TSN 128u                     // The tile-size in dvolension N
#define TSK 16u                      // The tile-size in dvolension K
#define WPTM 8u                     // The amount of work-per-thread in dvolension M
#define WPTN 8u                     // The amount of work-per-thread in dvolension N
#define RTSM (TSM/WPTM)     // The reduced tile-size in dvolension M (TSM/WPTM number of threads)
#define RTSN (TSN/WPTN)     // The reduced tile-size in dvolension N (TSN/WPTN number of threads)
#define LPTA uint(float(TSK*WPTM*WPTN)/float(TSN)) // Loads-per-thread for A
#define LPTB uint(float(TSK*WPTM*WPTN)/float(TSM)) // Loads-per-thread for B
#define MOD2(x,y) ((x) % (y))
#define DIV2(x,y) ((x) / (y))
#define CEIL_DIV(x,y) (((x) + (y) - 1) / (y))


layout(push_constant) uniform pushBlock {
      int total;
      int batchsize;
      int M;
      int N;
      int K;
} p;

layout (local_size_x = RTSM, local_size_y = RTSN, local_size_z = 1) in;

layout (binding = 0) readonly buffer ssbA {
    float A[];
};

layout (binding = 1) buffer ssbB {
    float B[];
};

layout (binding = 2)  buffer ssbC {
  float C[];
};

shared float asub[2][TSK*TSM];
shared float bsub[2][TSK*TSN];

void gemm_2(){
    uint M = p.M; uint N = p.N; uint K = p.K;
    uint tidm = gl_LocalInvocationID.x;
    uint tidn = gl_LocalInvocationID.y;
    uint gidm = gl_WorkGroupID.x;
    uint gidn = gl_WorkGroupID.y;
    uint tid = tidn*RTSM + tidm;
  
    float Areg;
    float Breg[WPTN];
    float acc[WPTM][WPTN];
    for(uint wm = 0; wm < WPTM; ++wm){
        for(uint wn = 0; wn < WPTN; ++wn){
            acc[wm][wn] = 0.0f;
        }
    }

    for(uint la=0; la < LPTA; ++la){
        uint id = la*RTSM*RTSN + tid;
        uint row = MOD2(id,TSM);
        uint col = DIV2(id,TSM);
        uint tiledIndex = TSK*0 + col;
        uint m_idx = gidm*TSM + row;
        uint indexA =  tiledIndex*p.M + m_idx;    
        if(m_idx < M)
            asub[0][col*TSM + row] = A[indexA];
        else
            asub[0][col*TSM + row] = 0.;
    }

    for(uint lb=0; lb < LPTB; ++lb){
        uint id = lb*RTSN*RTSM + tid;
        uint row = MOD2(id,TSN);
        uint col = DIV2(id,TSN);
        uint tiledIndex = TSK*0 + col;
        uint n_idx = gidn*TSN + row;
        uint indexB = tiledIndex*p.N + n_idx;
        if(n_idx < N)
            bsub[0][col*TSN + row] = B[indexB];
        else    
            bsub[0][col*TSN + row] = 0.;
    }

    uint numTiles = CEIL_DIV(K,TSK);
    if(numTiles == 0)
        numTiles = 1;
        
    for(uint t = 0; t < numTiles; ++t){
        uint tt = t+1;
        barrier();
        if(tt < numTiles){
            for(uint la=0; la<LPTA; ++la){
                uint id = la*RTSN*RTSM + tid;
                uint row = MOD2(id,TSM);
                uint col = DIV2(id,TSM);
                uint tiledIndex = TSK*tt + col;
                uint m_idx = gidm*TSM + row;
                uint indexA = tiledIndex*p.M + m_idx;
                if(m_idx < M)
                    asub[tt%2][col*TSM + row] = A[indexA];
                else   
                    asub[tt%2][col*TSM + row] = 0.;            
            }
            for(uint lb=0; lb<LPTB; ++lb){
                uint id = lb*RTSN*RTSM + tid;
                uint row = MOD2(id,TSN);
                uint col = DIV2(id,TSN);
                uint tiledIndex = TSK*tt + col;
                uint n_idx = gidn*TSN + row;
                uint indexB = tiledIndex*p.N + n_idx;
                if(n_idx < N)
                    bsub[tt%2][col*TSN + row] = B[indexB];
                else
                    bsub[tt%2][col*TSN + row] = 0.;
            }
        }

        for(uint k = 0; k < TSK; ++k){
            for(uint wn=0; wn<WPTN; ++wn){
                uint col = tidn + wn*RTSN;
                Breg[wn] = bsub[t%2][k*TSN + col];
            }

            for(uint wm=0; wm < WPTM; ++wm){
                uint row = tidm + wm*RTSM;
                Areg = asub[t%2][k*TSM + row];
                for (uint wn=0; wn < WPTN; ++wn) {
                    acc[wm][wn] = fma(Areg, Breg[wn], acc[wm][wn]);
                }
            }
        }        
    }

    for (uint wm=0; wm<WPTM; wm++) {
        uint globalRow = gidm*TSM + tidm + wm*RTSM;
        for (uint wn=0; wn<WPTN; wn++) {
            uint globalCol = gidn*TSN + tidn + wn*RTSN;
            if(globalCol < N && globalRow < M)
                C[globalCol*M + globalRow] = acc[wm][wn];
        }
    }
}

void main() {
    gemm_2();
}