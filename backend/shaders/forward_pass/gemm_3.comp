#version 460

layout(push_constant) uniform pushBlock {
      int total;
      int batchsize;
      int M;
      int N;
      int K;      
} p;

layout (local_size_x = 128, local_size_y = 1, local_size_z = 1) in;

layout (binding = 0) readonly buffer ssbA {
    float A[];
};

layout (binding = 1) buffer ssbB {
    float B[];
};

layout (binding = 2) writeonly buffer ssbC {
  float C[];
};

//https://arxiv.org/pdf/2002.03258.pdf
#define t1 128
#define t2 16
#define t3 32

shared float currB[t1*t2];


void TSM2R(){
    uint m = p.M; uint n = p.N; uint k = p.K;
    float currA[t3];
    float nextA[t3];
    float nextB[t2];
    float currC[t2];
    uint tid = gl_LocalInvocationID.x;   
    for(uint threadBase = gl_WorkGroupID.x * gl_WorkGroupSize.x; threadBase < m; threadBase += gl_NumWorkGroups.x * gl_WorkGroupSize.x){ 
        uint thread = threadBase + tid;
        for(uint p = 0; p < n; p+=t2){
            if(thread < m){
                #pragma unroll
                for(uint i = 0; i < t2; ++i){
                    if(p+i < n)
                        currC[i] = 0.0;
                }
                #pragma unroll
                for(uint i = 0; i < t3; ++i){
                    if(i < k)
                        currA[i] = A[thread + i*m];
                }               
            }
            if(tid < k){
                #pragma unroll
                for(uint i = 0; i < t2; ++i){
                    if(p+i < n)
                        currB[tid + (i * t1)] = B[tid + (p + i) * k];
                }
            }
            for(uint j = 0; j < k; j+=t1){
                barrier();
                if(j+t1+tid < k){
                    #pragma unroll
                    for(uint i = 0; i < t2; ++i){
                        if(p+i < n)
                            nextB[i] = B[(j+t1+tid) + ((p + i) * k)];
                    }
                }
                uint t3mod = t1%t3;
                for(uint l = j; l < j+(t1-t3mod) && l < k; l+=t3){
                    #pragma unroll
                    for(uint i = 0; i < t3; ++i){
                        if(l + t3 + i < k && thread < m)
                             nextA[i] = A[thread + ((l + t3 + i) * m)];                        
                    }
                    if (l + t3 <= k) {
                        #pragma unroll
                        for (uint a = 0; a < t2; ++a) {
                            #pragma unroll
                            for (uint b = 0; b < t3; ++b) {
                                currC[a] += currA[b] * currB[(l - j) + b + (a * t1)];
                            }
                        }
                    } else {
                        #pragma unroll
                        for (uint a = 0; a < t2; ++a) {
                            #pragma unroll
                            for (uint b = 0; b < t3; ++b) {
                                if (l + b < k) 
                                    currC[a] += currA[b] * currB[(l - j) + b + (a * t1)];
                            }
                        }
                    }
                    #pragma unroll
                    for(uint i = 0; i < t3; ++i)
                        currA[i] = nextA[i];
                }
                #pragma unroll
                for(uint a = 0; a < t2; ++a){
                    #pragma unroll
                    for(uint b = 0; b < t3mod; ++b){
                        if(j+t1-t3mod+b < k){
                            currC[a] += currA[b] * currB[(t1 - t3mod + b) + (a * t1)];
                        }
                    }
                }
                barrier();
                #pragma unroll
                for (uint i = 0; i < t2; ++i) 
                    currB[tid + (i * t1)] = nextB[i];
                if (t3mod != 0) {
                    #pragma unroll
                    for (uint i = 0; i < t3; ++i) {
                        if (j + t1 + i < k && thread < m) 
                            currA[i] = A[thread + ((j + t1 + i) * m)];
                            
                    }
                }
            }
            
            if(thread < m){
                #pragma unroll
                for(uint i = 0; i < t2; ++i){
                    if(p+i < n)
                        C[thread + ((p + i) * m)] = currC[i];
                }
            }

        }
       
    } 
}


void main(){
    TSM2R();
}