#version 460
#define TSM 128                     // The tile-size in dvolension M
#define TSN 128                     // The tile-size in dvolension N
#define TSK 16                      // The tile-size in dvolension K
#define WPTM 8                      // The amount of work-per-thread in dvolension M
#define WPTN 8                      // The amount of work-per-thread in dvolension N
#define LPTA ((TSK*TSM)/(RTSM*RTSN)) // Loads-per-thread for A
#define LPTB ((TSK*TSN)/(RTSM*RTSN)) // Loads-per-thread for B
#define RTSM (TSM/WPTM)    // The reduced tile-size in dvolension M (TSM/WPTM number of threads)
#define RTSN (TSN/WPTN)   // The reduced tile-size in dvolension N (TSN/WPTN number of threads)

#define global_x(M) (M/WPTM)
#define global_y(N) (N/WPTN)

layout(push_constant) uniform pushBlock {
      int total;
      int batchsize;
      int M;
      int N;
      int K;
} p;

layout (local_size_x = RTSM, local_size_y = RTSN, local_size_z = 1) in;

layout (binding = 0) readonly buffer ssbA {
    float X[];
};

layout (binding = 1) readonly buffer ssbB {
    float W[];
};

layout (binding = 2) readonly buffer ssbC {
    float DY[];
};

layout (binding = 3) writeonly buffer ssbD {
    float DW[];
};

layout (binding = 4) writeonly buffer ssbE {
    float DX[];
};

void d_gemm(){
    for(uint globalDepth = gl_GlobalInvocationID.z; globalDepth < p.batchsize; globalDepth += gl_NumWorkGroups.z * gl_WorkGroupSize.z){
        for (uint globalRow = gl_GlobalInvocationID.x; globalRow < p.M; globalRow += gl_NumWorkGroups.x * gl_WorkGroupSize.x){
            for (uint globalCol = gl_GlobalInvocationID.y; globalCol < p.N; globalCol += gl_NumWorkGroups.y * gl_WorkGroupSize.y){
                float acc = 0.0;
                for (uint k=0u; k < p.K; k++){
                
                }
            }
        }
    }
}

void main() {
    d_gemm();
}