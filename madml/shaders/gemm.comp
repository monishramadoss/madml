#version 450
#define TSM 128                     // The tile-size in dimension M
#define TSN 128                     // The tile-size in dimension N
#define TSK 16                      // The tile-size in dimension K
#define WPTM 8                      // The amount of work-per-thread in dimension M
#define WPTN 8                      // The amount of work-per-thread in dimension N
#define LPTA ((TSK*WPTM*WPTN)/(TSN)) // The amount of loads-per-thread for A
#define LPTB ((TSK*WPTM*WPTN)/(TSM)) // The amount of loads-per-thread for B
#define RTSM 16    // The reduced tile-size in dimension M (TSM/WPTM number of threads)
#define RTSN 16    // The reduced tile-size in dimension N (TSN/WPTN number of threads)
#define MOD2(x,y) ((x) % (y))
#define DIV2(x,y) ((x) / (y))

layout(push_constant) uniform pushBlock {
      int M;
      int N;
      int K;
      int use_bias;
} p;

layout (binding = 0) readonly buffer buf1 {
    float A[];
};

layout (binding = 1) readonly buffer buf2 {
    float B[];
};

layout (binding = 2) readonly buffer buf3{
    float C[];
};

layout (binding = 3) writeonly buffer buf4 {
    float D[];
};


layout (local_size_x = 8, local_size_y = 8, local_size_z = 1) in;

void main() {
    int M = p.M;
    int N = p.N;
    int K = p.K;
    uint globalRow = gl_GlobalInvocationID.x; // Row ID of C (0..M)
    uint globalCol = gl_GlobalInvocationID.y; // Col ID of C (0..N)

    // Compute a single element (loop over K)
    if(globalCol >= M || globalRow >= N)
        return;
    float acc = 0.0;
    for (int k= 0; k < K; k++)
        acc += A[k*M + globalRow] * B[globalCol*K + k];

    // Store the result
    D[globalCol*M + globalRow] = acc;
}