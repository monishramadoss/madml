#version 450
#define LOCAL_SZ_X 1024

layout(push_constant) uniform pushBlock {
	    int batchsize;
        int channels;
        int kernel_h;
        int kernel_w;
        int kernel_d;
        int pad_h;
        int pad_w;
        int pad_d;
        int stride_h;
        int stride_w;
        int stride_d;
        int dilation_h;
        int dilation_w;
        int dilation_d; 
 
        int height_col; // height + 2 * pad_h - (dilation_h * (kernel_h - 1) + 1)) / stride_h + 1
        int width_col;  // width + 2 * pad_w - (dilation_w * (kernel_w - 1) + 1)) / stride_w + 1
        int depth_col;  // depth + 2 * pad_d - (dilation-d * (kernel_d - 1) + 1)) / stride_d + 1

        int height_im;
        int width_im;
        int depth_im;
};
layout(binding = 0) buffer buf1 {
    float A[];
};

layout(binding = 1) buffer buf2 {
    float B[];
};

layout (local_size_x = 16, local_size_y = 64, local_size_z = 1) in;


void col2im(){
    uint n_output_plane = channels / (kernel_h * kernel_w * kernel_d);
    uint channels_col = channels * kernel_h * kernel_w * kernel_d;

    uint elt = gl_GlobalInvocationID.x;
    if(elt >= batchsize)
        return;

    uint data_col = elt * n_output_plane * height_im * width_im * depth_im;
    uint data_im = elt * channels * height_col * width_col * depth_col;
    
    uint c_col = gl_GlobalInvocationID.y;
    if(c_col >= channels_col)
        return;

    uint w_offset = c_col % kernel_w;
    uint h_offset = (c_col / kernel_w) % kernel_h;
    uint d_offset = (c_col / kernel_w / kernel_h) % kernel_d;
    uint c_im = c_col / kernel_w / kernel_h / kernel_d;

    for (uint d_col = 0; d_col < depth_col; ++d_col){
        uint d_im = d_col * stride_d - pad_d + d_offset * dilation_d;
        for (uint h_col = 0; h_col < height_col; ++h_col){
            uint h_im = h_col * stride_h - pad_h + h_offset * dilation_h;
            for (uint w_col = 0; w_col < width_col; ++w_col){
                uint w_im = w_col * stride_w - pad_w + w_offset * dilation_w;

                if (0 <= h_im && h_im < height_im && 0 <= w_im && w_im < width_im && 0 <= d_im && d_im < depth_im){
                    B[data_im + ((c_im * depth_im + d_im) * height_im + h_im) * width_im + w_im] += 
                    A[data_col + ((c_col * depth_col + d_col) * height_col + h_col) * width_col + w_col];
                }         
            }     
        }
    }
}    

 void main(){
   col2im();
}