#version 450
#define TSM 128                     // The tile-size in dvolension M
#define TSN 128                     // The tile-size in dvolension N
#define TSK 16                      // The tile-size in dvolension K
#define WPTM 8                      // The amount of work-per-thread in dvolension M
#define WPTN 8                      // The amount of work-per-thread in dvolension N
#define LPTA ((TSK*WPTM*WPTN)/(TSN)) // The amount of loads-per-thread for A
#define LPTB ((TSK*WPTM*WPTN)/(TSM)) // The amount of loads-per-thread for B
#define RTSM 16    // The reduced tile-size in dvolension M (TSM/WPTM number of threads)
#define RTSN 16    // The reduced tile-size in dvolension N (TSN/WPTN number of threads)
#define MOD2(x,y) ((x) % (y))
#define DIV2(x,y) ((x) / (y))


layout(push_constant) uniform pushBlock {
      int M;
      int N;
      int K;
} p;

layout (local_size_x = RTSM, local_size_y = RTSN, local_size_z = 1) in;

layout (binding = 0) readonly buffer ssbA {
  float A[];
};
layout (binding = 1) readonly buffer ssbB {
  float B[];
};
layout (binding = 2) writeonly buffer ssbC {
  float C[];
};

shared float Asub[TSK][TSM];    // Local memory to fit a tile of A and B
shared float Bsub[TSN][TSK+2];

void main() {
    int M = p.M;
    int N = p.N;
    int K = p.K;

   	// Compute a single element (loop over K)
   	for (uint globalRow = gl_GlobalInvocationID.x; globalRow < M; globalRow += gl_NumWorkGroups.x * gl_WorkGroupSize.x){
 		for (uint globalCol = gl_GlobalInvocationID.y; globalCol < N; globalCol += gl_NumWorkGroups.y * gl_WorkGroupSize.y){
	        float acc = 0.0;
            for (uint k=0u; k < K; k++)
                acc += A[k*M + globalRow] * B[globalCol*K + k];
            C[globalCol*M + globalRow] = acc;
        }
    }     

}