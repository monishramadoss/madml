#version 450

layout(push_constant) uniform pushBlock {
      int vocab_size;
      int hidden_size;
      int out_size;
      int in_offset;
      int weight_offset;
} p;

layout (local_size_x = 32, local_size_y = 32, local_size_z = 1) in;

layout (binding = 0) readonly buffer ssbA {
    float U[];
};

layout (binding = 1) readonly buffer ssbB {
    float V[];
};

layout (binding = 2) readonly buffer ssbC {
    float W[];
};

layout (binding = 3) readonly buffer ssbD {
    float A[];
};

layout (binding = 4) readonly buffer ssbE {
    float B[];
};

layout(binding = 5) readonly buffer ssbF{
	 float C[];
};

layout (binding = 6) readonly buffer ssbG {
    float bias[];
};

layout (binding = 7) readonly buffer ssbH {
    float bias2[];
};

layout (binding = 8) buffer ssbI {
    float D[];
};

layout (binding = 9) buffer ssbJ {
    float E[];
};

layout (binding = 10) buffer ssbK {
    float G[];
};

void gemm_1(){
  	int M = p.hidden_size;
  	int K = p.vocab_size;
  	int N = 1;
   	for (uint globalRow = gl_GlobalInvocationID.x; globalRow < M; globalRow += gl_NumWorkGroups.x * gl_WorkGroupSize.x){
      	float i = bias[globalRow*4 + 0];
        float f = bias[globalRow*4 + 1];
        float g = bias[globalRow*4 + 2];
        float o = bias[globalRow*4 + 3];
        
        for (uint k=0u; k < p.vocab_size; k++){
            i += U[k*M*4 + globalRow*4 + 0] * A[p.in_offset*K + k];
            f += U[k*M*4 + globalRow*4 + 1] * A[p.in_offset*K + k];
            g += U[k*M*4 + globalRow*4 + 2] * A[p.in_offset*K + k];
            o += U[k*M*4 + globalRow*4 + 3] * A[p.in_offset*K + k];
               
        }

        for (uint k=0u; k < p.hiddens_size; k++){
            i += W[k*M*4 + globalRow*4 + 0] * B[p.weight_offset*K + k];
            f += W[k*M*4 + globalRow*4 + 1] * B[p.weight_offset*K + k];
            g += W[k*M*4 + globalRow*4 + 2] * B[p.weight_offset*K + k];
            o += W[k*M*4 + globalRow*4 + 3] * B[p.weight_offset*K + k];
        } 

        barrier();
        i = 1/(1+exp(-i));
        f = 1/(1+exp(-f));
        g = tanh(g);
        o = tanh(o);
        float ct = f * C[p.weight_offset*M + globalRow] + i * g;
        G[p.weight_offset*M + globalRow] = ct;
        D[p.weight_offset*M + globalRow] = o * tanh(ct);
    }     
}

void gemm_3(){
	int M = p.out_size;
	int K = p.hidden_size;
	int N = 1;
   	for (uint globalRow = gl_GlobalInvocationID.y; globalRow < M; globalRow += gl_NumWorkGroups.y * gl_WorkGroupSize.y){
 		    float acc = bias2[globalRow];
            for (uint k=0u; k < K; k++)
                acc += V[k*M + globalRow] * G[p.weight_offset*K + k];
            E[p.in_offset*M + globalRow] = 1/(1+exp(-acc)); //sigmoid
    }         
}



void main(){
	gemm_1();
	barrier();
	gemm_3();
} 