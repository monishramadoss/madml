#version 450

layout(push_constant) uniform pushBlock {
      int vocab_size;
      int hidden_size;
      int output_size;
      int input_offset;
      int weight_offset;
      int output_offset;
} p;

layout (local_size_x = 32, local_size_y = 32, local_size_z = 1) in;

layout (binding = 0) readonly buffer ssbA {
    float U[];
};

layout (binding = 1) readonly buffer ssbB {
    float V[];
};

layout (binding = 2) readonly buffer ssbC {
    float W[];
};

layout (binding = 3) readonly buffer ssbD {
    float A[];
};

layout (binding = 4) readonly buffer ssbE {
    float B[];
};

layout (binding = 5) readonly buffer ssbF {
    float bias[];
};

layout (binding = 6) readonly buffer ssbG {
    float bias2[];
};

layout (binding = 7) buffer ssbH {
    float C[];
};

layout (binding = 8) buffer ssbI{
    float D[];
};

void gemm_1(){
    for (uint globalRow = gl_GlobalInvocationID.x; globalRow < p.hidden_size; globalRow += gl_NumWorkGroups.x * gl_WorkGroupSize.x){
        float r = bias[globalRow*3 + 0];
        float z = bias[globalRow*3 + 1];
        float n = bias[globalRow*3 + 2];

        for (uint k=0u; k < p.vocab_size; ++k){
            r += U[k*p.vocab_size*3 + globalRow*3 + 0] * A[p.input_offset + k];
            z += U[k*p.vocab_size*3 + globalRow*3 + 1] * A[p.input_offset + k];
            n += U[k*p.vocab_size*3 + globalRow*3 + 2] * A[p.input_offset + k];
        }
        for (uint k=0u; k < p.hidden_size; ++k){
            r += W[k*p.hidden_size*3 + globalRow*3 + 0] * B[p.weight_offset + k];
            z += W[k*p.hidden_size*3 + globalRow*3 + 1] * B[p.weight_offset + k];
        }
        
        for (uint k=0; k < p.hidden_size; ++k){
            n += r * W[k*p.hidden_size*3 + globalRow*3 + 2] * B[p.weight_offset + k];
        }
        r = 1/(1+exp(-r));
        z = 1/(1+exp(-z));
        n = tanh(n);

        C[p.weight_offset + globalRow] = (1-z) * n + z * B[p.weight_offset + globalRow];
    }     
}

void gemm_2(){
   	for (uint globalRow = gl_GlobalInvocationID.y; globalRow < p.output_size; globalRow += gl_NumWorkGroups.y * gl_WorkGroupSize.y){
        float acc = bias2[globalRow];
        for (uint k=0u; k < p.hidden_size; ++k)
            acc += V[k*p.output_size + globalRow] * C[p.weight_offset + k];
        C[p.output_offset + globalRow] = 1.0/(1.0 + exp(-acc)); //sigmoid
    }         
}

void main(){
	gemm_1();
    barrier();
	gemm_2();
} 