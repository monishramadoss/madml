#version 450
#define LOCAL_SZ_X 1024

layout(push_constant) uniform pushBlock {
    int n;
    int data_im;
    int data_col;
    int num_axes;

    int kernel_shape_h;
    int kernel_shape_w;
    int kernel_shape_d;

    int pad_h;
    int pad_w;
    int pad_d;

    int stride_h;
    int stride_w;
    int stride_d;

    int dialate_h;
    int dialate_w;
    int dialate_d;

    int output_h;
    int output_w;
    int output_d;
    int output_c;

    int input_h;
    int input_w;
    int input_d;
    int input_c;
};

layout(binding = 0) buffer buf1 {
    float A[];
};

layout(binding = 1) buffer buf2 {
    float B[];
};

layout(binding = 2) buffer buf3 {
    float C[];
};

layout (local_size_x = 256, local_size_y = 1, local_size_z = 1) in;


shared int shared_dialate[8];
shared int shared_kernel_shape[8];
shared int shared_pad[8];
shared int shared_stride[8];
shared int shared_col_shape[8 + 1];
shared int shared_im_shape[8 + 1];

void im2col_nd(){
    
    int d_temp[8];  // NOLINT(runtime/arrays)
    int d_iter[8];  // NOLINT(runtime/arrays)
    int i;    
    int num_axes = 3;
    shared_dialate[0] = dialate_h;
    shared_kernel_shape[0] = kernel_shape_h;
    shared_pad[0] = pad_h;
    shared_stride[0] = stride_h;
    shared_col_shape[0] = output_h;
    shared_im_shape[0] = input_h;

    shared_dialate[0] = dialate_h;
    shared_kernel_shape[1] = kernel_shape_w;
    shared_pad[1] = pad_w;
    shared_stride[1] = stride_w;
    shared_col_shape[1] = output_w;
    shared_im_shape[1] = input_w;

    shared_dialate[2] = dialate_w;
    shared_kernel_shape[2] = kernel_shape_w;
    shared_pad[2] = pad_w;
    shared_stride[2] = stride_w;
    shared_col_shape[2] = output_w;
    shared_im_shape[2] = input_w;

    shared_col_shape[3] = output_c;
    shared_im_shape[3] = input_c;

    barrier();
    for(int index = int(gl_GlobalInvocationID.x); index < n; index += int(gl_NumWorkGroups.x * gl_WorkGroupSize.x)){
        for(int batch_n = int(gl_GlobalInvocationID.y); batch_n < n; batch_n += int(gl_NumWorkGroups.y * gl_WorkGroupSize.y)){
        }
        int channel_in = index;
        int channel_out = 1;
        for (i = num_axes - 1; i >= 0; --i) {
            d_temp[i] = channel_in % shared_col_shape[i + 1];
            channel_in /= shared_col_shape[i + 1];
            channel_out *= shared_kernel_shape[i];
        }
        channel_out *= channel_in;
        int data_col_inc = 1;
        for (i = 0; i < num_axes; ++i) {
            channel_out *= shared_col_shape[i + 1];
            channel_out += d_temp[i];
            d_temp[i] = d_temp[i] * shared_stride[i] - shared_pad[i];
            channel_in *= shared_im_shape[i + 1];
            channel_in += d_temp[i];
            data_col_inc *= shared_col_shape[i + 1];
            d_iter[i] = 0;
        }

        barrier();
    
        int data_col_ptr = data_col + channel_out;
        int data_im_ptr = data_im + channel_in;
        bool incremented;
        do {
            bool in_range = true;
            for (i = 0; i < num_axes; ++i) {
                int d_iter_im = d_iter[i] * shared_dialate[i] + d_temp[i];
                in_range = in_range && bool(d_iter_im >= 0 && d_iter_im < shared_im_shape[i + 1]);
                if (!in_range) { break; }
            }
            if (in_range) {
                int data_im_offset = d_iter[0] * shared_dialate[0];
                for (i = 1; i < num_axes; ++i) {
                    data_im_offset *= shared_im_shape[i + 1];
                    data_im_offset += d_iter[i] * shared_dialate[i];
                }
                B[data_col_ptr] = A[data_im_ptr + data_im_offset];
            } else {
                B[data_col_ptr] = 0;
            }
            data_col_ptr += data_col_inc;
            incremented = false;
            for (i = num_axes - 1; i >= 0; --i) {
                const int d_max = shared_kernel_shape[i];
                if (d_iter[i] == d_max - 1) {
                    d_iter[i] = 0;
                } else {  // d_iter[i] < d_max - 1
                    ++d_iter[i];
                    incremented = true;
                    break;
                }
            }  
        } while (incremented);
    }
}



void col2im_nd(){
    int d_im[8];  // NOLINT(runtime/arrays)
    int d_col_iter[8];  // NOLINT(runtime/arrays)
    int d_col_start[8];  // NOLINT(runtime/arrays)
    int d_col_end[8];  // NOLINT(runtime/arrays)
    
    shared_dialate[0] = dialate_h;
    shared_kernel_shape[0] = kernel_shape_h;
    shared_pad[0] = pad_h;
    shared_stride[0] = stride_h;
    shared_col_shape[0] = output_h;
    shared_im_shape[0] = input_h;

    shared_dialate[0] = dialate_h;
    shared_kernel_shape[1] = kernel_shape_w;
    shared_pad[1] = pad_w;
    shared_stride[1] = stride_w;
    shared_col_shape[1] = output_w;
    shared_im_shape[1] = input_w;

    shared_dialate[2] = dialate_w;
    shared_kernel_shape[2] = kernel_shape_w;
    shared_pad[2] = pad_w;
    shared_stride[2] = stride_w;
    shared_col_shape[2] = output_w;
    shared_im_shape[2] = input_w;

    shared_col_shape[3] = output_c;
    shared_im_shape[3] = input_c;

    barrier();

    for(int index = int(gl_GlobalInvocationID.x); index < n; index += int(gl_NumWorkGroups.x * gl_WorkGroupSize.x)){
        int c_im = index;
        for (int i = num_axes - 1; i >= 0; --i) {
            d_im[i] = c_im % shared_im_shape[i + 1] + shared_pad[i];
            c_im /= shared_im_shape[i + 1];
        }    

        bool done = false;
        for (int i = 0; i < num_axes; ++i) {
            const int kernel_extent = shared_dialate[i] * (shared_kernel_shape[i] - 1) + 1;
            d_col_start[i] = d_col_iter[i] = (d_im[i] < kernel_extent) ? 0 : (d_im[i] - kernel_extent) / shared_stride[i] + 1;
            d_col_end[i] = min(d_im[i] / shared_stride[i] + 1, shared_col_shape[i + 1]);
            if (d_col_start[i] >= d_col_end[i]) {
                C[data_im + index] = 0;
                done = true;
                break;
            }
        }
        if (done) {
            continue;  // CUDA_KERNEL_LOOP(index, n)
        }
        float val = 0;
        bool incremented = true;
        bool skip = false;
        do {
            // Compute the final offset.
            int final_offset = 0;
            int kernel_shape_prod = 1;
            int kernel_index;
            for (int i = num_axes - 1; i >= 0; --i) {
                kernel_index = d_im[i] - d_col_iter[i] * shared_stride[i];
                if (kernel_index % shared_dialate[i] != 0) {
                    skip = true;
                    break;
                } else {
                    kernel_index /= shared_dialate[i];
                    final_offset += kernel_index * kernel_shape_prod;
                    kernel_shape_prod *= shared_kernel_shape[i];
                }
            }
            if (!skip) {
                final_offset += kernel_shape_prod * c_im;
                for (int i = 0; i < num_axes; ++i) {
                    final_offset *= shared_col_shape[i + 1];
                    final_offset += d_col_iter[i];
                }
                val += B[data_col + final_offset];
            }
            skip = false;
            incremented = false;
            for (int i = num_axes - 1; i >= 0; --i) {
                const int d_max = d_col_end[i];
                if (d_col_iter[i] == d_max - 1) {
                    d_col_iter[i] = d_col_start[i];
                } else {  // d_col_iter[i] < d_max - 1
                    ++d_col_iter[i];
                    incremented = true;
                    break;  // for (int i = num_axes - 1; i >= 0; --i)
                }
            }  // for (int i = num_axes - 1; i >= 0; --i)
        }  while (incremented);
        C[data_im + index] = val;
    }
}


void main(){
   im2col_nd();
   col2im_nd();
}